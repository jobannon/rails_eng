FUNCTION  <SNR>22_is_excluded_ft()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 199
Called 7 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    7              0.000044   if !exists("g:delimitMate_excluded_ft")
    7              0.000017     return 0
                              endif
                              return index(split(g:delimitMate_excluded_ft, ','), a:ft, 0, 1) >= 0

FUNCTION  <SNR>87_get_hunks_gitgutter()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/hunks.vim line 27
Called 216 times
Total time:   0.016672
 Self time:   0.004911

count  total (s)   self (s)
  216   0.004022   0.002433   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
  216              0.000084   endif
  216   0.012176   0.002003   return GitGutterGetHunkSummary()

FUNCTION  <SNR>93_check_mixed_indent_file()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/whitespace.vim line 32
Called 3 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    3              0.000020   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    3              0.000012   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    3              0.000002   else
    3              0.000004     let head_spc = '\v(^ +)'
    3              0.000002   endif
    3              0.000042   let indent_tabs = search('\v(^\t+)', 'nw')
    3              0.000041   let indent_spc  = search(head_spc, 'nw')
    3              0.000004   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    3              0.000001   else
    3              0.000002     return ''
                              endif

FUNCTION  <SNR>122_ContinuedHangingOperator()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 656
Called 2 times
Total time:   0.002013
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000003   let info = a:msl_info
                            
                              " If the previous line ended with [*+/.,-=], but wasn't a block ending or a
                              " closing bracket, indent one extra level.
    2   0.001986   0.000022   if s:Match(info.plnum_msl, s:non_bracket_continuation_regex) && !s:Match(info.plnum_msl, '^\s*\([\])}]\|end\)')
                                if info.plnum_msl == info.plnum
                                  let ind = indent(info.plnum_msl) + info.sw
                                else
                                  let ind = indent(info.plnum_msl)
                                endif
                                return ind
    2              0.000001   endif
                            
    2              0.000002   return -1

FUNCTION  <SNR>131_process_added()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 292
Called 14 times
Total time:   0.004675
 Self time:   0.004675

count  total (s)   self (s)
   14              0.000023   let offset = 0
  671              0.000547   while offset < a:to_count
  657              0.000708     let line_number = a:to_line + offset
  657              0.002144     call add(a:modifications, [line_number, 'added'])
  657              0.000713     let offset += 1
  671              0.000327   endwhile

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/coc.vim line 14
Called 216 times
Total time:   0.006819
 Self time:   0.002035

count  total (s)   self (s)
  216   0.006691   0.001906   return airline#extensions#coc#get('error')

FUNCTION  airline#check_mode()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline.vim line 199
Called 234 times
Total time:   0.542910
 Self time:   0.029207

count  total (s)   self (s)
  234              0.000850   if !has_key(s:contexts, a:winnr)
                                return ''
  234              0.000236   endif
  234              0.000707   let context = s:contexts[a:winnr]
                            
  234              0.000779   if get(w:, 'airline_active', 1)
  216              0.000649     let l:m = mode(1)
  216              0.000356     if l:m ==# "i"
  136              0.000252       let l:mode = ['insert']
   80              0.000169     elseif l:m[0] ==# "i"
   18              0.000029       let l:mode = ['insert']
   62              0.000090     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
   62              0.000114     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
   62              0.000719     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   62              0.000118     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   62              0.000087     elseif l:m[0] ==# "c"
    2              0.000008       let l:mode = ['commandline']
   60              0.000090     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
   60              0.000111     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
   60              0.000046     else
   60              0.000152       let l:mode = ['normal']
  216              0.000125     endif
  216              0.001129     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
  216              0.000101     endif
  216              0.001592     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
  198              0.000384       let l:m = l:m[0]
  216              0.000107     endif
  216              0.001105     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   18              0.000026   else
   18              0.000049     let l:mode = ['inactive']
   18              0.000091     let w:airline_current_mode = get(g:airline_mode_map, '__')
  234              0.000123   endif
                            
  234              0.000687   if g:airline_detect_modified && &modified
  216              0.000685     call add(l:mode, 'modified')
  234              0.000117   endif
                            
  234              0.000381   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
  234              0.000132   endif
                            
  234              0.001519   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
  234              0.000105   endif
                            
  234              0.000397   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
  234              0.000107   endif
                            
  234              0.000344   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
  234              0.000099   endif
                            
  234              0.001169   let mode_string = join(l:mode)
  234              0.000960   if get(w:, 'airline_lastmode', '') != mode_string
    8   0.003998   0.000162     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    8   0.509122   0.000271     call airline#highlighter#highlight(l:mode, context.bufnr)
    8   0.001085   0.000068     call airline#util#doautocmd('AirlineModeChanged')
    8              0.000018     let w:airline_lastmode = mode_string
  234              0.000098   endif
                            
  234              0.000223   return ''

FUNCTION  <SNR>86_exec_separator()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 189
Called 736 times
Total time:   0.367463
 Self time:   0.032350

count  total (s)   self (s)
  736              0.000972   if pumvisible()
                                return
  736              0.000245   endif
  736              0.002081   let group = a:from.'_to_'.a:to.a:suffix
  736   0.104865   0.006346   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  736   0.093273   0.006221   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  736              0.000552   if a:inverse
  272              0.000843     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  464              0.000197   else
  464              0.001400     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  736              0.000256   endif
  736              0.002986   let a:dict[group] = colors
  736   0.156972   0.007430   call airline#highlighter#exec(group, colors)

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/branch.vim line 168
Called 216 times
Total time:   0.002996
 Self time:   0.002996

count  total (s)   self (s)
  216              0.000862   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
  216              0.000988   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
  216              0.000098   endif

FUNCTION  <SNR>105_has_fresh_changes()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter.vim line 168
Called 29 times
Total time:   0.000937
 Self time:   0.000462

count  total (s)   self (s)
   29   0.000898   0.000424   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>68_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/plugin/matchparen.vim line 39
Called 78 times
Total time:   0.007859
 Self time:   0.007859

count  total (s)   self (s)
                              " Remove any previous match.
   78              0.000314   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
   78              0.000055   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   78              0.000354   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   78              0.000067   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   78              0.000216   let c_lnum = line('.')
   78              0.000220   let c_col = col('.')
   78              0.000090   let before = 0
                            
   78              0.000201   let text = getline(c_lnum)
   78              0.001737   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   78              0.000163   if empty(matches)
                                let [c_before, c] = ['', '']
   78              0.000053   else
   78              0.000365     let [c_before, c] = matches[1:2]
   78              0.000043   endif
   78              0.001560   let plist = split(&matchpairs, '.\zs[:,]')
   78              0.000250   let i = index(plist, c)
   78              0.000084   if i < 0
                                " not found, in Insert mode try character before the cursor
   78              0.000290     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   52              0.000112       let before = strlen(c_before)
   52              0.000054       let c = c_before
   52              0.000090       let i = index(plist, c)
   78              0.000061     endif
   78              0.000082     if i < 0
                                  " not found, nothing to do
   78              0.000063       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>87_is_branch_empty()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/hunks.vim line 22
Called 216 times
Total time:   0.001589
 Self time:   0.001589

count  total (s)   self (s)
  216              0.001439   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/coc.vim line 10
Called 216 times
Total time:   0.007819
 Self time:   0.002076

count  total (s)   self (s)
  216   0.007681   0.001938   return airline#extensions#coc#get('warning')

FUNCTION  <SNR>91_ModifierFlags()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/fugitiveline.vim line 11
Called 234 times
Total time:   0.001029
 Self time:   0.001029

count  total (s)   self (s)
  234              0.000893   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/tabline/buffers.vim line 51
Called 21 times
Total time:   0.005951
 Self time:   0.000576

count  total (s)   self (s)
   21              0.000028   try
   21   0.005558   0.000183     call <sid>map_keys()
                              catch
                                " no-op
   21              0.000017   endtry
   21              0.000063   let cur = bufnr('%')
   21              0.000071   if cur == s:current_bufnr && &columns == s:column_width
   21              0.000092     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
   21              0.000045       return s:current_tabline
                                endif
                              endif
                            
                              let b = airline#extensions#tabline#new_builder()
                              let tab_bufs = tabpagebuflist(tabpagenr())
                              let show_buf_label_first = 0
                            
                              if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
                              if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
                              endif
                            
                              let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
                              let b.overflow_group = 'airline_tabhid'
                              let b.buffers = airline#extensions#tabline#buflist#list()
                              if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
                              function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
                              if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
                              endif
                            
                              function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
                              let current_buffer = max([index(b.buffers, cur), 0])
                              let last_buffer = len(b.buffers) - 1
                              call b.insert_titles(current_buffer, 0, last_buffer)
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                              if !show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 1)
                              endif
                            
                              call airline#extensions#tabline#add_tab_label(b)
                            
                              let s:current_bufnr = cur
                              let s:column_width = &columns
                              let s:current_tabline = b.build()
                              let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
                              return s:current_tabline

FUNCTION  <SNR>90_update_untracked()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/branch.vim line 177
Called 216 times
Total time:   0.040449
 Self time:   0.037453

count  total (s)   self (s)
  216              0.018650   let file = expand("%:p")
  216              0.002783   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
  216              0.000120   endif
                            
  216              0.000360   let needs_update = 1
  216              0.001053   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  648              0.001436   for vcs in keys(s:vcs_config)
  432              0.002412     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
  432              0.000247     endif
  432              0.001383     if has_key(s:vcs_config[vcs].untracked, file)
  216              0.000300       let needs_update = 0
  216   0.006528   0.003531       call airline#extensions#branch#update_untracked_config(file, vcs)
  432              0.000211     endif
  648              0.000618   endfor
                            
  216              0.000225   if !needs_update
  216              0.000152     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && !airline#util#has_fugitive()
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/util.vim line 131
Called 216 times
Total time:   0.001913
 Self time:   0.001913

count  total (s)   self (s)
  216              0.000668   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
  216              0.000121   endif
  216              0.000242   return s:has_fugitive

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc/util.vim line 90
Called 24 times
Total time:   0.000692
 Self time:   0.000692

count  total (s)   self (s)
   24              0.000244   let pos = getcurpos()
   24              0.000278   let content = pos[2] == 1 ? '' : getline('.')[0: pos[2] - 2]
   24              0.000118   return [pos[1] - 1, strchars(content)]

FUNCTION  GetRubyIndent()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 154
Called 2 times
Total time:   0.022753
 Self time:   0.001999

count  total (s)   self (s)
                              " 2.1. Setup {{{2
                              " ----------
                            
    2              0.000016   let indent_info = {}
                            
                              " The value of a single shift-width
    2              0.000013   if exists('*shiftwidth')
    2              0.000008     let indent_info.sw = shiftwidth()
                              else
                                let indent_info.sw = &sw
    2              0.000002   endif
                            
                              " For the current line, use the first argument if given, else v:lnum
    2              0.000007   let indent_info.clnum = a:0 ? a:1 : v:lnum
    2              0.000009   let indent_info.cline = getline(indent_info.clnum)
                            
                              " Set up variables for restoring position in file.  Could use clnum here.
    2              0.000007   let indent_info.col = col('.')
                            
                              " 2.2. Work on the current line {{{2
                              " -----------------------------
    2              0.000014   let indent_callback_names = [ 's:AccessModifier', 's:ClosingBracketOnEmptyLine', 's:BlockComment', 's:DeindentingKeyword', 's:MultilineStringOrLineComment', 's:ClosingHeredocDelimiter', 's:LeadingOperator', ]
                            
   16              0.000064   for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
   14   0.002332   0.000515     let indent = call(function(callback_name), [indent_info])
                            
   14              0.000029     if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
   14              0.000021     endif
   16              0.000024   endfor
                            
                              " 2.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " Special case: we don't need the real s:PrevNonBlankNonString for an empty
                              " line inside a string. And that call can be quite expensive in that
                              " particular situation.
    2              0.000026   let indent_callback_names = [ 's:EmptyInsideString', ]
                            
    4              0.000031   for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
    2   0.004529   0.000109     let indent = call(function(callback_name), [indent_info])
                            
    2              0.000011     if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
    2              0.000008     endif
    4              0.000012   endfor
                            
                              " Previous line number
    2   0.002494   0.000054   let indent_info.plnum = s:PrevNonBlankNonString(indent_info.clnum - 1)
    2              0.000008   let indent_info.pline = getline(indent_info.plnum)
                            
    2              0.000016   let indent_callback_names = [ 's:StartOfFile', 's:AfterAccessModifier', 's:ContinuedLine', 's:AfterBlockOpening', 's:AfterHangingSplat', 's:AfterUnbalancedBracket', 's:AfterLeadingOperator', 's:AfterEndKeyword', 's:AfterIndentKeyword', ]
                            
   20              0.000034   for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
   18   0.003372   0.000369     let indent = call(function(callback_name), [indent_info])
                            
   18              0.000022     if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
   18              0.000011     endif
   20              0.000017   endfor
                            
                              " 2.4. Work on the MSL line. {{{2
                              " --------------------------
    2              0.000013   let indent_callback_names = [ 's:PreviousNotMSL', 's:IndentingKeywordInMSL', 's:ContinuedHangingOperator', ]
                            
                              " Most Significant line based on the previous one -- in case it's a
                              " contination of something above
    2   0.006843   0.000024   let indent_info.plnum_msl = s:GetMSL(indent_info.plnum)
                            
    8              0.000013   for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
    6   0.002353   0.000099     let indent = call(function(callback_name), [indent_info])
                            
    6              0.000006     if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
    6              0.000003     endif
    8              0.000008   endfor
                            
                              " }}}2
                            
                              " By default, just return the previous line's indent
                            "  Decho "Default case matched"
    2              0.000006   return indent(indent_info.plnum)

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/async.vim line 14
Called 14 times
Total time:   0.039960
 Self time:   0.039175

count  total (s)   self (s)
   14   0.000827   0.000150   call gitgutter#debug#log('[async] '.a:cmd)
                            
   14              0.000087   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
   14   0.000362   0.000254   let command = s:build_command(a:cmd)
                            
   14              0.000042   if has('nvim')
   14              0.035929     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
   14              0.000016   endif

FUNCTION  <SNR>86_get_syn()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 37
Called 5056 times
Total time:   0.126528
 Self time:   0.126528

count  total (s)   self (s)
 5056              0.011077   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
 5056              0.001946   endif
 5056              0.004036   let color = ''
 5056              0.019367   if hlexists(a:group)
 4384              0.024598     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 5056              0.002062   endif
 5056              0.008553   if empty(color) || color == -1
                                " should always exists
  672              0.006317     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  672              0.001230     if empty(color) || color == -1
                                  let color = 'NONE'
  672              0.000260     endif
 5056              0.001483   endif
 5056              0.003720   return color

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline.vim line 279
Called 8 times
Total time:   0.000191
 Self time:   0.000152

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    8              0.000092   let g:airline#visual_active = (mode() =~? '[vs]')
    8   0.000084   0.000044   call airline#update_tabline()

FUNCTION  <SNR>28_Slash()
    Defined: ~/.vim/z_plugins/vim-fugitive/plugin/fugitive.vim line 281
Called 216 times
Total time:   0.001427
 Self time:   0.001427

count  total (s)   self (s)
  216              0.000569   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  216              0.000101   else
  216              0.000267     return a:path
                              endif

FUNCTION  delimitMate#IsEmptyPair()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 282
Called 7 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    7              0.000062   if strlen(substitute(a:str, ".", "x", "g")) != 2
    7              0.000006     return 0
                              endif
                              let idx = index(s:get('left_delims'), matchstr(a:str, '^.'))
                              if idx > -1 && s:get('right_delims')[idx] == matchstr(a:str, '.$')
                                return 1
                              endif
                              let idx = index(s:get('quotes_list'), matchstr(a:str, '^.'))
                              if idx > -1 && s:get('quotes_list')[idx] == matchstr(a:str, '.$')
                                return 1
                              endif
                              return 0

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 166
Called 14 times
Total time:   0.006398
 Self time:   0.000531

count  total (s)   self (s)
   14   0.003204   0.000318   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
   14   0.003163   0.000182   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/util.vim line 156
Called 8 times
Total time:   0.001016
 Self time:   0.000575

count  total (s)   self (s)
    8   0.001012   0.000571   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>122_ExtraBrackets()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 836
Called 2 times
Total time:   0.001338
 Self time:   0.000463

count  total (s)   self (s)
    2              0.000012   let opening = {'parentheses': [], 'braces': [], 'brackets': []}
    2              0.000009   let closing = {'parentheses': [], 'braces': [], 'brackets': []}
                            
    2              0.000006   let line = getline(a:lnum)
    2              0.000024   let pos  = match(line, '[][(){}]', 0)
                            
                              " Save any encountered opening brackets, and remove them once a matching
                              " closing one has been found. If a closing bracket shows up that doesn't
                              " close anything, save it for later.
    6              0.000010   while pos != -1
    4   0.000923   0.000048     if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  if line[pos] == '('
                                    call add(opening.parentheses, {'type': '(', 'pos': pos})
                                  elseif line[pos] == ')'
                                    if empty(opening.parentheses)
                                      call add(closing.parentheses, {'type': ')', 'pos': pos})
                                    else
                                      let opening.parentheses = opening.parentheses[0:-2]
                                    endif
                                  elseif line[pos] == '{'
                                    call add(opening.braces, {'type': '{', 'pos': pos})
                                  elseif line[pos] == '}'
                                    if empty(opening.braces)
                                      call add(closing.braces, {'type': '}', 'pos': pos})
                                    else
                                      let opening.braces = opening.braces[0:-2]
                                    endif
                                  elseif line[pos] == '['
                                    call add(opening.brackets, {'type': '[', 'pos': pos})
                                  elseif line[pos] == ']'
                                    if empty(opening.brackets)
                                      call add(closing.brackets, {'type': ']', 'pos': pos})
                                    else
                                      let opening.brackets = opening.brackets[0:-2]
                                    endif
                                  endif
    4              0.000002     endif
                            
    4              0.000042     let pos = match(line, '[][(){}]', pos + 1)
    6              0.000015   endwhile
                            
                              " Find the rightmost brackets, since they're the ones that are important in
                              " both opening and closing cases
    2              0.000008   let rightmost_opening = {'type': '(', 'pos': -1}
    2              0.000006   let rightmost_closing = {'type': ')', 'pos': -1}
                            
    2              0.000009   for opening in opening.parentheses + opening.braces + opening.brackets
                                if opening.pos > rightmost_opening.pos
                                  let rightmost_opening = opening
                                endif
    2              0.000003   endfor
                            
    2              0.000006   for closing in closing.parentheses + closing.braces + closing.brackets
                                if closing.pos > rightmost_closing.pos
                                  let rightmost_closing = closing
                                endif
    2              0.000002   endfor
                            
    2              0.000005   return [rightmost_opening, rightmost_closing]

FUNCTION  <SNR>90_update_hg_branch()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/branch.vim line 123
Called 216 times
Total time:   0.013191
 Self time:   0.011598

count  total (s)   self (s)
  216   0.003418   0.001825   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
  216              0.000130   else
  216              0.000531     let s:vcs_config['mercurial'].branch = ''
  216              0.000148   endif

FUNCTION  <SNR>22_get_syn_name()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 191
Called 7 times
Total time:   0.002262
 Self time:   0.002262

count  total (s)   self (s)
    7              0.000033   let col = col('.')
    7              0.000015   if  col == col('$')
    7              0.000010     let col = col - 1
    7              0.000004   endif
    7              0.002183   return synIDattr(synIDtrans(synID(line('.'), col, 1)), 'name')

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 204
Called 14 times
Total time:   0.001183
 Self time:   0.000532

count  total (s)   self (s)
   14              0.000048   let hunks = []
   28              0.000127   for line in split(a:diff, '\n')
   14   0.000806   0.000155     let hunk_info = gitgutter#diff#parse_hunk(line)
   14              0.000023     if len(hunk_info) == 4
   14              0.000028       call add(hunks, hunk_info)
   14              0.000007     endif
   28              0.000022   endfor
   14              0.000012   return hunks

FUNCTION  <SNR>43_winshell()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 74
Called 14 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
   14              0.000144   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>131_is_added()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 272
Called 14 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
   14              0.000036   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>51_on_cursor_moved()
    Defined: ~/.vim/z_plugins/vim-airline/plugin/airline.vim line 74
Called 25 times
Total time:   0.001255
 Self time:   0.000998

count  total (s)   self (s)
   25              0.000309   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
   25              0.000125   endif
   25   0.000623   0.000366   call airline#update_tabline()

FUNCTION  <SNR>125_Slash()
    Defined: ~/.vim/z_plugins/vim-fugitive/autoload/fugitive.vim line 94
Called 648 times
Total time:   0.004132
 Self time:   0.004132

count  total (s)   self (s)
  648              0.001731   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  648              0.000334   else
  648              0.000608     return a:path
                              endif

FUNCTION  FugitiveVimPath()
    Defined: ~/.vim/z_plugins/vim-fugitive/plugin/fugitive.vim line 269
Called 216 times
Total time:   0.001462
 Self time:   0.001462

count  total (s)   self (s)
  216              0.000554   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
  216              0.000105   else
  216              0.000230     return a:path
                              endif

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/fugitiveline.vim line 15
Called 234 times
Total time:   0.031049
 Self time:   0.030020

count  total (s)   self (s)
  234              0.000760   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir') && exists('*fugitive#repo')
                                    if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
                                    endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
                                endtry
  234              0.000103   endif
                            
  234   0.003531   0.002502   let fmod = s:ModifierFlags()
  234              0.000465   if empty(b:fugitive_name)
  234              0.019636     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/z_plugins/vim-fugitive/plugin/fugitive.vim line 11
Called 432 times
Total time:   0.014132
 Self time:   0.012706

count  total (s)   self (s)
  432              0.001695   if !a:0 || type(a:1) == type(0) && a:1 < 0
  216              0.000501     if exists('g:fugitive_event')
                                  return g:fugitive_event
  216              0.000116     endif
  216              0.000732     let dir = get(b:, 'git_dir', '')
  216              0.000883     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
  216              0.000100     endif
  216              0.000218     return dir
  216              0.000504   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
  216              0.000472   elseif type(a:1) == type('')
  216   0.004528   0.003102     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>122_IsInStringOrDocumentation()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 692
Called 2 times
Total time:   0.000510
 Self time:   0.000093

count  total (s)   self (s)
    2   0.000503   0.000086   return s:IsInRubyGroup(s:syng_stringdoc, a:lnum, a:col)

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/tabline.vim line 145
Called 21 times
Total time:   0.007012
 Self time:   0.001061

count  total (s)   self (s)
   21              0.000161   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   21              0.000059   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   21              0.000047   let curtabcnt = tabpagenr('$')
   21              0.000039   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                                call airline#extensions#tabline#tabws#invalidate()
   21              0.000019   endif
                            
   21              0.000069   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
   21              0.000008   endif
   21              0.000017   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
   21              0.000020   elseif s:tabws
                                return airline#extensions#tabline#tabws#get()
   21              0.000036   elseif show_buffers && curtabcnt == 1 || !show_tabs
   21   0.006180   0.000229     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 94
Called 14 times
Total time:   0.002552
 Self time:   0.000215

count  total (s)   self (s)
   14   0.002538   0.000201   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>122_AfterIndentKeyword()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 586
Called 2 times
Total time:   0.000380
 Self time:   0.000157

count  total (s)   self (s)
    2              0.000004   let info = a:pline_info
    2   0.000239   0.000017   let col = s:Match(info.plnum, s:ruby_indent_keywords)
                            
    2              0.000024   if col > 0
                                call cursor(info.plnum, col)
                                let ind = virtcol('.') - 1 + info.sw
                                " TODO: make this better (we need to count them) (or, if a searchpair
                                " fails, we know that something is lacking an end and thus we indent a
                                " level
                                if s:Match(info.plnum, s:end_end_regex)
                                  let ind = indent('.')
                                elseif s:IsAssignment(info.pline, col)
                                  if g:ruby_indent_assignment_style == 'hanging'
                                    " hanging indent
                                    let ind = col + info.sw - 1
                                  else
                                    " align with variable
                                    let ind = indent(info.plnum) + info.sw
                                  endif
                                endif
                                return ind
    2              0.000001   endif
                            
    2              0.000002   return -1

FUNCTION  <SNR>93_check_mixed_indent()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/whitespace.vim line 15
Called 3 times
Total time:   0.003570
 Self time:   0.003570

count  total (s)   self (s)
    3              0.000012   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    3              0.000003   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    3              0.000003   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
    3              0.000002   else
    3              0.003521     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/hunk.vim line 8
Called 14 times
Total time:   0.000259
 Self time:   0.000131

count  total (s)   self (s)
   14   0.000232   0.000104   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>98_map_keys()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/tabline/buffers.vim line 196
Called 21 times
Total time:   0.005375
 Self time:   0.005375

count  total (s)   self (s)
   21              0.000087   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   21              0.000022   if bidx_mode > 0
   21              0.000017     if bidx_mode == 1
  210              0.000260       for i in range(1, 9)
  189              0.003913         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-1)
  210              0.000158       endfor
                                else
                                  for i in range(11, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-11)
                                  endfor
   21              0.000011     endif
   21              0.000320     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   21              0.000276     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
   21              0.000012   endif

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/parts.vim line 59
Called 216 times
Total time:   0.001911
 Self time:   0.001911

count  total (s)   self (s)
  216              0.001725   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/hunks.vim line 46
Called 216 times
Total time:   0.023832
 Self time:   0.007159

count  total (s)   self (s)
  216              0.001200   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
  216              0.000102   endif
  216   0.019462   0.002790   return {b:source_func}()

FUNCTION  <SNR>93_ws_refresh()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/whitespace.vim line 178
Called 15 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
   15              0.000092   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
   12              0.000013     return
    3              0.000002   endif
    3              0.000032   unlet! b:airline_whitespace_check
    3              0.000010   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    3              0.000002   endif
    3              0.000014   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>28_Tree()
    Defined: ~/.vim/z_plugins/vim-fugitive/plugin/fugitive.vim line 146
Called 216 times
Total time:   0.003573
 Self time:   0.003573

count  total (s)   self (s)
  216              0.000401   let dir = a:path
  216              0.002198   if dir =~# '/\.git$'
  216              0.000786     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  delimitMate#WithinEmptyPair()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 299
Called 7 times
Total time:   0.000754
 Self time:   0.000262

count  total (s)   self (s)
                              " if cursor is at column 1 return 0
    7              0.000021   if col('.') == 1
                                return 0
    7              0.000005   endif
                              " get char before the cursor.
    7   0.000335   0.000070   let char1 = s:get_char(-1)
                              " get char under the cursor.
    7   0.000223   0.000076   let char2 = s:get_char(0)
    7   0.000143   0.000063   return delimitMate#IsEmptyPair( char1.char2 )

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/async.vim line 9
Called 14 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
   14              0.000050   return s:available

FUNCTION  <SNR>131_write_buffer()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 374
Called 14 times
Total time:   0.008904
 Self time:   0.008904

count  total (s)   self (s)
   14              0.001102   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
   14              0.000076   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
   14              0.000011   endif
                            
   14              0.000079   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
   14              0.000009   endif
                            
   14              0.000044   if getbufvar(a:bufnr, '&endofline')
   14              0.000050     call add(bufcontents, '')
   14              0.000009   endif
                            
   14              0.000051   let fenc = getbufvar(a:bufnr, '&fileencoding')
   14              0.000031   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
   14              0.000008   endif
                            
   14              0.000037   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]=''.bufcontents[0]
   14              0.000008   endif
                            
   14              0.007096   call writefile(bufcontents, a:file, 'b')

FUNCTION  airline#parts#get()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/parts.vim line 49
Called 432 times
Total time:   0.001914
 Self time:   0.001914

count  total (s)   self (s)
  432              0.001669   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/parts.vim line 63
Called 216 times
Total time:   0.000795
 Self time:   0.000795

count  total (s)   self (s)
  216              0.000651   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 104
Called 1056 times
Total time:   0.236994
 Self time:   0.064820

count  total (s)   self (s)
 1056              0.001601   if pumvisible()
                                return
 1056              0.000392   endif
 1056              0.001354   let colors = a:colors
 1056              0.000862   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
 1056              0.000413   endif
 1056   0.126534   0.010387   let old_hi = airline#highlighter#get_highlight(a:group)
 1056              0.001698   if len(colors) == 4
  736              0.001382     call add(colors, '')
 1056              0.000392   endif
 1056              0.001272   if g:airline_gui_mode ==# 'gui'
 1056              0.003328     let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
 1056              0.000408   endif
 1056   0.029482   0.008256   let colors = s:CheckDefined(colors)
 1056   0.014238   0.006784   if old_hi != new_hi || !s:hl_group_exists(a:group)
  408   0.031040   0.003693     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
  408              0.002845     exe cmd
  408              0.000972     if has_key(s:hl_groups, a:group)
  408              0.000799       let s:hl_groups[a:group] = colors
  408              0.000180     endif
 1056              0.000340   endif

FUNCTION  <SNR>50_notify()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc/client.vim line 133
Called 158 times
Total time:   0.014265
 Self time:   0.013146

count  total (s)   self (s)
  158   0.003067   0.001948   let channel = s:get_channel(self)
  158              0.000520   if empty(channel) | return '' | endif
  158              0.000137   try
  158              0.000215     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  158              0.000113     else
  158              0.004810       call call('rpcnotify', [channel, a:method] + a:args)
  158              0.000192     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  158              0.000148   endtry

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/whitespace.vim line 57
Called 216 times
Total time:   0.034152
 Self time:   0.023724

count  total (s)   self (s)
  216              0.000783   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  216              0.001151   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
  216              0.000081   endif
  216              0.002176   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  216              0.000642   if !exists('b:airline_whitespace_check')
    3              0.000006     let b:airline_whitespace_check = ''
    3              0.000014     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    3              0.000004     let trailing = 0
    3              0.000003     let check = 'trailing'
    3              0.000025     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    3              0.000003       try
    3              0.000009         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    3              0.000097         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    3              0.000003       endtry
    3              0.000001     endif
                            
    3              0.000003     let mixed = 0
    3              0.000003     let check = 'indent'
    3              0.000021     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    3   0.003601   0.000031       let mixed = s:check_mixed_indent()
    3              0.000004     endif
                            
    3              0.000006     let mixed_file = ''
    3              0.000004     let check = 'mixed-indent-file'
    3              0.000026     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    3   0.000187   0.000039       let mixed_file = s:check_mixed_indent_file()
    3              0.000001     endif
                            
    3              0.000003     let long = 0
    3              0.000007     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    3              0.000001     endif
                            
    3              0.000003     let conflicts = 0
    3              0.000005     if index(checks, 'conflicts') > -1
    3   0.000805   0.000025       let conflicts = s:conflict_marker()
    3              0.000002     endif
                            
    3              0.000009     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
    3              0.000007       let b:airline_whitespace_check = s:symbol
    3              0.000006       if strlen(s:symbol) > 0
    3              0.000006         let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
    3              0.000001       endif
                            
    3              0.000003       if s:show_message
    3              0.000002         if trailing != 0
    3              0.000010           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    3              0.000018           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    3              0.000001         endif
    3              0.000002         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
    3              0.000001         endif
    3              0.000002         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
    3              0.000001         endif
    3              0.000005         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
    3              0.000001         endif
    3              0.000003         if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
    3              0.000001         endif
    3              0.000001       endif
    3              0.000001     endif
  216              0.000086   endif
  216   0.007652   0.001721   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>131_save_last_seen_change()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 405
Called 14 times
Total time:   0.000400
 Self time:   0.000160

count  total (s)   self (s)
   14   0.000394   0.000154   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/parts.vim line 67
Called 216 times
Total time:   0.006664
 Self time:   0.006664

count  total (s)   self (s)
  216              0.003092   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  216              0.000420   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
  216              0.000076   endif
  216              0.000159   return ''

FUNCTION  <SNR>122_GetMSL()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 731
Called 2 times
Total time:   0.006819
 Self time:   0.000524

count  total (s)   self (s)
                              " Start on the line we're at and use its indent.
    2              0.000004   let msl = a:lnum
    2   0.002470   0.000049   let lnum = s:PrevNonBlankNonString(a:lnum - 1)
    2              0.000004   while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
    2              0.000006     let line = getline(lnum)
                            
    2   0.000211   0.000056     if !s:Match(msl, s:backslash_continuation_regex) && s:Match(lnum, s:backslash_continuation_regex)
                                  " If the current line doesn't end in a backslash, but the previous one
                                  " does, look for that line's msl
                                  "
                                  " Example:
                                  "   foo = "bar" \
                                  "     "baz"
                                  "
                                  let msl = lnum
    2   0.000132   0.000051     elseif s:Match(msl, s:leading_operator_regex)
                                  " If the current line starts with a leading operator, keep its indent
                                  " and keep looking for an MSL.
                                  let msl = lnum
    2   0.000082   0.000020     elseif s:Match(lnum, s:splat_regex)
                                  " If the above line looks like the "*" of a splat, use the current one's
                                  " indentation.
                                  "
                                  " Example:
                                  "   Hash[*
                                  "     method_call do
                                  "       something
                                  "
                                  return msl
    2   0.000231   0.000024     elseif s:Match(lnum, s:non_bracket_continuation_regex) && s:Match(msl, s:non_bracket_continuation_regex)
                                  " If the current line is a non-bracket continuation and so is the
                                  " previous one, keep its indent and continue looking for an MSL.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two,
                                  "     three
                                  "
                                  let msl = lnum
    2   0.000109   0.000027     elseif s:Match(lnum, s:dot_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a dot, keep going to see if the previous line is the
                                  " start of another continuation.
                                  "
                                  " Example:
                                  "   parent.
                                  "     method_call {
                                  "     three
                                  "
                                  let msl = lnum
    2   0.000197   0.000026     elseif s:Match(lnum, s:non_bracket_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a non-bracket one, respect the previous' indentation,
                                  " and stop here.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two {
                                  "     three
                                  "
                                  return lnum
    2   0.000112   0.000041     elseif s:Match(lnum, s:bracket_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If both lines are bracket continuations (the current may also be a
                                  " block-starter), use the current one's and stop here
                                  "
                                  " Example:
                                  "   method_call(
                                  "     other_method_call(
                                  "       foo
                                  return msl
    2   0.003157   0.000112     elseif s:Match(lnum, s:block_regex) && !s:Match(msl, s:continuation_regex) && !s:Match(msl, s:block_continuation_regex)
                                  " If the previous line is a block-starter and the current one is
                                  " mostly ordinary, use the current one as the MSL.
                                  "
                                  " Example:
                                  "   method_call do
                                  "     something
                                  "     something_else
    2              0.000002       return msl
                                else
                                  let col = match(line, s:continuation_regex) + 1
                                  if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                    let msl = lnum
                                  else
                                    break
                                  endif
                                endif
                            
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl

FUNCTION  <SNR>93_conflict_marker()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/whitespace.vim line 50
Called 3 times
Total time:   0.000780
 Self time:   0.000780

count  total (s)   self (s)
                              " Checks for git conflict markers
    3              0.000006   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    3              0.000012   let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    3              0.000755   return search(pattern, 'nw')

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim line 12
Called 147 times
Total time:   0.019909
 Self time:   0.017528

count  total (s)   self (s)
  147              0.000425   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
  147              0.000131   let _ = ''
                            
  147              0.000322   let name = bufname(a:bufnr)
  147              0.000222   if empty(name)
                                let _ .= '[No Name]'
  147              0.000082   else
  147              0.000123     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D//t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
  147              0.011898       let _ .= pathshorten(fnamemodify(name, fmod))
                                else
                                  let _ .= fnamemodify(name, fmod)
  147              0.000069     endif
  147              0.000529     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
  147              0.000060     endif
  147              0.000058   endif
                            
  147   0.004592   0.002211   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/branch.vim line 224
Called 216 times
Total time:   0.199305
 Self time:   0.008434

count  total (s)   self (s)
  216              0.000722   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
  216              0.000119   endif
                            
  216   0.152375   0.001954   call s:update_branch()
  216   0.043924   0.003475   call s:update_untracked()
                            
  216              0.000882   if exists('b:airline_head') && !empty(b:airline_head)
  216              0.000251     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '' : '.')
                                endif
                              endif
                            
                              return b:airline_head

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 70
Called 14 times
Total time:   0.065964
 Self time:   0.005383

count  total (s)   self (s)
   14   0.000731   0.000254   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
   14              0.000011   endif
                            
   14   0.000599   0.000140   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
   14              0.000009   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
   14              0.000022   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
   14              0.000070   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
   14              0.000044   let s:counter = (s:counter + 1) % 20
   14              0.000058   let buff_file .= '.'.s:counter
                            
   14   0.002717   0.000165   let extension = gitgutter#utility#extension(a:bufnr)
   14              0.000041   if !empty(extension)
   14              0.000057     let buff_file .= '.'.extension
   14              0.000013   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
   14   0.009598   0.000693   call s:write_buffer(a:bufnr, buff_file)
                            
   14              0.000069   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
   14              0.000101     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
   14              0.000059     let from_file .= '.'.s:counter
                            
   14              0.000052     if !empty(extension)
   14              0.000045       let from_file .= '.'.extension
   14              0.000013     endif
                            
                                " Write file from index to temporary file.
   14   0.001364   0.000310     let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
   14              0.000167     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
   14              0.000012   endif
                            
                              " Call git-diff.
   14              0.000097   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager '.g:gitgutter_git_args
   14              0.000019   if s:c_flag
   14              0.000037     let cmd .= ' -c "diff.autorefreshindex=0"'
   14              0.000034     let cmd .= ' -c "diff.noprefix=false"'
   14              0.000041     let cmd .= ' -c "core.safecrlf=false"'
   14              0.000009   endif
   14              0.000109   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
   14              0.000053   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
   14   0.000959   0.000255     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
   14              0.000010   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
   14              0.000039   let cmd .= ' || exit 0'
                            
   14              0.000030   let cmd .= ')'
                            
   14   0.006565   0.000167   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
   14   0.000297   0.000225   if g:gitgutter_async && gitgutter#async#available()
   14   0.041030   0.001070     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
   14              0.000065     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/parts.vim line 55
Called 216 times
Total time:   0.010710
 Self time:   0.002884

count  total (s)   self (s)
  216   0.010533   0.002706   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  fugitive#Find()
    Defined: ~/.vim/z_plugins/vim-fugitive/autoload/fugitive.vim line 837
Called 216 times
Total time:   0.086176
 Self time:   0.056655

count  total (s)   self (s)
  216              0.000724   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
  216              0.001854   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
  216   0.006301   0.004766   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
  216   0.004464   0.003058   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
  216              0.000120   endif
  216              0.000609   let dir = a:0 ? a:1 : s:Dir()
  216              0.000361   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
  216              0.000077   endif
  216   0.002818   0.001628   let rev = s:Slash(a:object)
  216   0.020416   0.001991   let tree = s:Tree(dir)
  216              0.000641   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
  216              0.000274   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
  216              0.000987   elseif rev =~# '^\.git/'
  216              0.001639     let f = substitute(rev, '^\.git', '', '')
  216   0.007601   0.002100     let cdir = fugitive#CommonDir(dir)
  216              0.001293     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
  216              0.000987     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
  216              0.001279     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
  216              0.000119     else
  216              0.000762       let f = simplify(dir . f)
  216              0.000115     endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^[^:.-][^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^[^:.-][^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
  216              0.000100   endif
  216   0.003056   0.001594   return FugitiveVimPath(f)

FUNCTION  coc#_complete()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc.vim line 57
Called 6 times
Total time:   0.004769
 Self time:   0.003264

count  total (s)   self (s)
    6              0.000027   let items = get(g:coc#_context, 'candidates', [])
    6              0.000015   let preselect = get(g:coc#_context, 'preselect', -1)
    6   0.004611   0.003106   call complete( g:coc#_context.start + 1, items)
    6              0.000058   if s:select_api && len(items) && preselect != -1
                                call nvim_select_popupmenu_item(preselect, v:false, v:false, {})
    6              0.000006   endif
    6              0.000009   return ''

FUNCTION  <SNR>122_EmptyInsideString()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 408
Called 2 times
Total time:   0.004420
 Self time:   0.000254

count  total (s)   self (s)
                              " If the line is empty and inside a string (the previous line is a string,
                              " too), use the previous line's indent
    2              0.000018   let info = a:pline_info
                            
    2              0.000032   let plnum = prevnonblank(info.clnum - 1)
    2              0.000021   let pline = getline(plnum)
                            
    2   0.004299   0.000133   if info.cline =~ '^\s*$' && s:IsInStringOrComment(plnum, 1) && s:IsInStringOrComment(plnum, strlen(pline))
                                return indent(plnum)
    2              0.000004   endif
    2              0.000010   return -1

FUNCTION  <SNR>131_process_hunk()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 239
Called 14 times
Total time:   0.006823
 Self time:   0.001173

count  total (s)   self (s)
   14              0.000018   let modifications = []
   14              0.000020   let from_line  = a:hunk[0]
   14              0.000015   let from_count = a:hunk[1]
   14              0.000013   let to_line    = a:hunk[2]
   14              0.000013   let to_count   = a:hunk[3]
                            
   14   0.000395   0.000341   if s:is_added(from_count, to_count)
   14   0.004802   0.000127     call s:process_added(modifications, from_count, to_count, to_line)
   14   0.001071   0.000150     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
                              elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
   14              0.000005   endif
   14              0.000014   return modifications

FUNCTION  airline#statusline()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline.vim line 190
Called 234 times
Total time:   0.004341
 Self time:   0.004341

count  total (s)   self (s)
  234              0.001909   if has_key(s:contexts, a:winnr)
  234              0.001978     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>122_BlockComment()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 327
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                              " If we have a =begin or =end set indent to first column.
    2              0.000031   if match(a:cline_info.cline, '^\s*\%(=begin\|=end\)$') != -1
                                return 0
    2              0.000001   endif
    2              0.000002   return -1

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 56
Called 29 times
Total time:   0.025079
 Self time:   0.003516

count  total (s)   self (s)
   29   0.025000   0.003437   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>22_is_forbidden()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 206
Called 7 times
Total time:   0.003192
 Self time:   0.000494

count  total (s)   self (s)
    7   0.000173   0.000099   if s:is_excluded_ft(&filetype)
                                return 1
    7              0.000007   endif
    7   0.000255   0.000056   if !s:get('excluded_regions_enabled')
                                return 0
    7              0.000003   endif
    7   0.002448   0.000186   let region = s:get_syn_name()
    7   0.000276   0.000114   return index(s:get('excluded_regions_list'), region) >= 0

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 67
Called 2528 times
Total time:   0.284968
 Self time:   0.140755

count  total (s)   self (s)
 2528              0.031776   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 2528              0.007701   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
 2528              0.001234   else
 2528   0.082276   0.017139     let fg = s:get_syn(a:group, 'fg')
 2528   0.077808   0.016418     let bg = s:get_syn(a:group, 'bg')
 2528              0.013581     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 2528              0.001955     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
 2528              0.001208     else
 2528   0.037066   0.019380       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
 2528              0.001089     endif
 2528              0.000840   endif
 2528              0.008807   let s:hl_groups[a:group] = res
 2528              0.001709   return res

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/util.vim line 27
Called 648 times
Total time:   0.021758
 Self time:   0.015323

count  total (s)   self (s)
  648   0.015126   0.008690   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                endif
  648              0.000306   else
  648              0.000644     return a:text
                              endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/branch.vim line 293
Called 216 times
Total time:   0.219078
 Self time:   0.010843

count  total (s)   self (s)
  216   0.201481   0.002177   let head = airline#extensions#branch#head()
  216   0.003585   0.002655   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
  216              0.000934   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  216   0.009868   0.001867   let head = airline#util#shorten(head, winwidth, minwidth)
  216              0.000940   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  216              0.001824   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  <SNR>43_dir()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 194
Called 43 times
Total time:   0.010046
 Self time:   0.001421

count  total (s)   self (s)
   43   0.010018   0.001393   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc/rpc.vim line 94
Called 158 times
Total time:   0.019904
 Self time:   0.004180

count  total (s)   self (s)
  158   0.003250   0.001792   if !coc#rpc#ready() | return '' | endif
  158   0.016198   0.001933   call s:client['notify'](a:method, a:args)
  158              0.000186   return ''

FUNCTION  <SNR>122_AfterEndKeyword()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 565
Called 2 times
Total time:   0.000137
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000006   let info = a:pline_info
                              " If the previous line ended with an "end", match that "end"s beginning's
                              " indent.
    2   0.000094   0.000019   let col = s:Match(info.plnum, '\%(^\|[^.:@$]\)\<end\>\s*\%(#.*\)\=$')
    2              0.000002   if col > 0
                                call cursor(info.plnum, col)
                                if searchpair(s:end_start_regex, '', s:end_end_regex, 'bW', s:end_skip_expr) > 0
                                  let n = line('.')
                                  let ind = indent('.')
                                  let msl = s:GetMSL(n)
                                  if msl != n
                                    let ind = indent(msl)
                                  end
                                  return ind
                                endif
    2              0.000001   end
    2              0.000002   return -1

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 24
Called 373 times
Total time:   0.007128
 Self time:   0.007128

count  total (s)   self (s)
  373              0.001821   let bvars = getbufvar(a:buffer, '')
  373              0.000867   if !empty(bvars)
  373              0.001450     let dict = get(bvars, 'gitgutter', {})
  373              0.001128     if has_key(dict, a:varname)
  344              0.000713       return dict[a:varname]
   29              0.000067     endif
   29              0.000031   endif
   29              0.000052   if a:0
   29              0.000069     return a:1
                              endif

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/util.vim line 62
Called 936 times
Total time:   0.006268
 Self time:   0.006268

count  total (s)   self (s)
  936              0.002010   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  936              0.000349   endif
  936              0.002645   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  coc#_do_complete()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc.vim line 69
Called 6 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
    6              0.000092   let g:coc#_context = { 'start': a:start, 'candidates': a:items, 'preselect': a:preselect}
    6              0.000035   if mode() =~# 'i' && &paste != 1
    6              0.000029     call feedkeys("\<Plug>CocRefresh", 'i')
    6              0.000003   endif

FUNCTION  <SNR>122_ContinuedLine()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 458
Called 2 times
Total time:   0.000530
 Self time:   0.000125

count  total (s)   self (s)
    2              0.000005   let info = a:pline_info
                            
    2   0.000260   0.000021   let col = s:Match(info.plnum, s:ruby_indent_keywords)
    2   0.000218   0.000053   if s:Match(info.plnum, s:continuable_regex) && s:Match(info.plnum, s:continuation_regex)
                                if col > 0 && s:IsAssignment(info.pline, col)
                                  if g:ruby_indent_assignment_style == 'hanging'
                                    " hanging indent
                                    let ind = col - 1
                                  else
                                    " align with variable
                                    let ind = indent(info.plnum)
                                  endif
                                else
                                  let ind = indent(s:GetMSL(info.plnum))
                                endif
                                return ind + info.sw + info.sw
    2              0.000001   endif
    2              0.000002   return -1

FUNCTION  <SNR>122_PrevNonBlankNonString()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 706
Called 4 times
Total time:   0.004861
 Self time:   0.000293

count  total (s)   self (s)
    4              0.000011   let in_block = 0
    4              0.000015   let lnum = prevnonblank(a:lnum)
    4              0.000007   while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
    4              0.000012     let line = getline(lnum)
    4              0.000024     if line =~ '^=begin'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
    4              0.000023     elseif !in_block && line =~ '^=end'
                                  let in_block = 1
    4   0.004684   0.000116     elseif !in_block && line !~ '^\s*#.*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
    4              0.000009       break
                                endif
                                let lnum = prevnonblank(lnum - 1)
    4              0.000014   endwhile
    4              0.000007   return lnum

FUNCTION  <SNR>43_exists_file()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 203
Called 29 times
Total time:   0.011584
 Self time:   0.001989

count  total (s)   self (s)
   29   0.011553   0.001958   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>132_highlight_name_for_change()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/sign.vim line 234
Called 657 times
Total time:   0.001532
 Self time:   0.001532

count  total (s)   self (s)
  657              0.000757   if a:text ==# 'added'
  657              0.000473     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  <SNR>125_Tree()
    Defined: ~/.vim/z_plugins/vim-fugitive/autoload/fugitive.vim line 308
Called 216 times
Total time:   0.018425
 Self time:   0.002199

count  total (s)   self (s)
  216   0.018251   0.002025   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/hunk.vim line 3
Called 14 times
Total time:   0.001030
 Self time:   0.000270

count  total (s)   self (s)
   14   0.000523   0.000143   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
   14   0.000468   0.000087   call s:reset_summary(a:bufnr)

FUNCTION  airline#extensions#vista#currenttag()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/vista.vim line 7
Called 234 times
Total time:   0.001467
 Self time:   0.001467

count  total (s)   self (s)
  234              0.000634   if get(w:, 'airline_active', 0)
  216              0.000559     return get(b:, 'vista_nearest_method_or_function', '')
   18              0.000026   endif

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/parts.vim line 102
Called 234 times
Total time:   0.004889
 Self time:   0.002801

count  total (s)   self (s)
  234   0.004726   0.002638   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '' : '>') : &filetype

FUNCTION  <SNR>90_update_git_branch()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/branch.vim line 87
Called 216 times
Total time:   0.124157
 Self time:   0.008045

count  total (s)   self (s)
  216   0.003855   0.001942   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
  216              0.000083   endif
                            
  216   0.117976   0.003776   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
  216              0.000806   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
  216              0.000106   endif

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter.vim line 23
Called 29 times
Total time:   0.098596
 Self time:   0.004599

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   29   0.026047   0.000968   if gitgutter#utility#is_active(a:bufnr)
                            
   29              0.000172     if has('patch-7.4.1559')
   29              0.000290       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   29              0.000024     endif
   29   0.002471   0.000453     let how = s:setup_path(a:bufnr, l:Callback)
   29              0.000105     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
   29              0.000020     endif
                            
   29   0.001283   0.000346     if a:force || s:has_fresh_changes(a:bufnr)
                            
   14              0.000023       let diff = ''
   14              0.000018       try
   14   0.066778   0.000814         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
   14              0.000018       endtry
                            
   14              0.000038       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
   14              0.000009       endif
                            
   29              0.000017     endif
   29              0.000016   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/parts.vim line 82
Called 216 times
Total time:   0.001464
 Self time:   0.001464

count  total (s)   self (s)
  216              0.000595   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
  216              0.000101   endif
  216              0.000143   return ''

FUNCTION  coc#util#close_popup()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc/util.vim line 132
Called 6 times
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
    6              0.000010   if s:is_vim
                                if exists('*popup_close')
                                  call popup_close(get(g:, 'coc_popup_id', 0))
                                endif
    6              0.000003   else
   30              0.000042     for winnr in range(1, winnr('$'))
   24              0.000041       if getwinvar(winnr, 'popup', 0)
                                    exe winnr.'close!'
   24              0.000009       endif
   30              0.000015     endfor
    6              0.000003   endif

FUNCTION  <SNR>22_get_char()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 108
Called 42 times
Total time:   0.000990
 Self time:   0.000990

count  total (s)   self (s)
   42              0.000120   let idx = col('.') - 1
   42              0.000087   if !a:0 || (a:0 && a:1 >= 0)
                                " Get char from cursor.
   21              0.000056     let line = getline('.')[idx :]
   21              0.000032     let pos = a:0 ? a:1 : 0
   21              0.000145     return matchstr(line, '^'.repeat('.', pos).'\zs.')
   21              0.000012   endif
                              " Get char behind cursor.
   21              0.000068   let line = getline('.')[: idx - 1]
   21              0.000033   let pos = 0 - (1 + a:1)
   21              0.000235   return matchstr(line, '.\ze'.repeat('.', pos).'$')

FUNCTION  airline#util#append()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/util.vim line 48
Called 1512 times
Total time:   0.016373
 Self time:   0.016373

count  total (s)   self (s)
 1512              0.003632   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1512              0.000684   endif
 1512              0.005395   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1512              0.004231   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>122_Match()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 898
Called 42 times
Total time:   0.007282
 Self time:   0.003101

count  total (s)   self (s)
   42              0.000172   let line   = getline(a:lnum)
   42              0.001673   let offset = match(line, '\C'.a:regex)
   42              0.000105   let col    = offset + 1
                            
   46   0.004487   0.000306   while offset > -1 && s:IsInStringOrComment(a:lnum, col)
    4              0.000183     let offset = match(line, '\C'.a:regex, offset + 1)
    4              0.000008     let col = offset + 1
   46              0.000093   endwhile
                            
   42              0.000059   if offset > -1
    2              0.000002     return col
   40              0.000044   else
   40              0.000040     return 0
                              endif

FUNCTION  <SNR>122_StartOfFile()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 424
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                              " At the start of the file use zero indent.
    2              0.000005   if a:pline_info.plnum == 0
                                return 0
    2              0.000002   endif
    2              0.000002   return -1

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/themes.vim line 31
Called 1472 times
Total time:   0.185571
 Self time:   0.016750

count  total (s)   self (s)
 1472   0.185084   0.016263   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/z_plugins/vim-fugitive/plugin/fugitive.vim line 133
Called 216 times
Total time:   0.016226
 Self time:   0.003341

count  total (s)   self (s)
  216   0.016070   0.003185   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>86_hl_group_exists()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 95
Called 648 times
Total time:   0.007454
 Self time:   0.007454

count  total (s)   self (s)
  648              0.002342   if !hlexists(a:group)
                                return 0
  648              0.003098   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  648              0.000264   endif
  648              0.000345   return 1

FUNCTION  <SNR>86_GetHiCmd()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 164
Called 408 times
Total time:   0.027347
 Self time:   0.027347

count  total (s)   self (s)
                              " a:list needs to have 5 items!
  408              0.000441   let res = ''
  408              0.000365   let i = -1
 2448              0.001689   while i < 4
 2040              0.001577     let i += 1
 2040              0.004017     let item = get(a:list, i, '')
 2040              0.002101     if item is ''
 1192              0.000625       continue
  848              0.000336     endif
  848              0.000573     if i == 0
  408              0.000993       let res .= ' guifg='.item
  440              0.000294     elseif i == 1
  376              0.000665       let res .= ' guibg='.item
   64              0.000036     elseif i == 2
                                  let res .= ' ctermfg='.item
   64              0.000039     elseif i == 3
                                  let res .= ' ctermbg='.item
   64              0.000038     elseif i == 4
   64              0.000266       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  848              0.000365     endif
 1256              0.001377   endwhile
  408              0.000389   return res

FUNCTION  <SNR>132_handle_double_hunk()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/sign.vim line 212
Called 14 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
   14              0.000076   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
   14              0.000006   endif
                            
   14              0.000012   return a:modified_lines

FUNCTION  <SNR>22_is_cr_expansion()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 122
Called 7 times
Total time:   0.000816
 Self time:   0.000407

count  total (s)   self (s)
    7              0.000033   let nchar = getline(line('.')-1)[-1:]
    7              0.000062   let schar = matchstr(getline(line('.')+1), '^\s*\zs\S')
    7              0.000030   let isEmpty = a:0 ? getline('.') =~ '^\s*$' : empty(getline('.'))
    7   0.000233   0.000110   if index(s:get('left_delims'), nchar) > -1 && index(s:get('left_delims'), nchar)    == index(s:get('right_delims'), schar) && isEmpty
                                return 1
    7   0.000430   0.000144   elseif index(s:get('quotes_list'), nchar) > -1 && index(s:get('quotes_list'), nchar)    == index(s:get('quotes_list'), schar) && isEmpty
                                return 1
    7              0.000003   else
    7              0.000004     return 0
                              endif

FUNCTION  <SNR>122_IsInRubyGroup()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 676
Called 18 times
Total time:   0.013920
 Self time:   0.013920

count  total (s)   self (s)
   18              0.001963   let ids = map(copy(a:groups), 'hlID("ruby".v:val)')
   18              0.011925   return index(ids, synID(a:lnum, a:col, 1)) >= 0

FUNCTION  coc#_hide()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc.vim line 94
Called 8 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    8              0.000038   if !pumvisible() | return | endif
    3              0.000012   call feedkeys("\<C-e>", 'in')

FUNCTION  <SNR>122_PreviousNotMSL()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 613
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000003   let info = a:msl_info
                            
                              " If the previous line wasn't a MSL
    2              0.000003   if info.plnum != info.plnum_msl
                                " If previous line ends bracket and begins non-bracket continuation decrease indent by 1.
                                if s:Match(info.plnum, s:bracket_switch_continuation_regex)
                                  " TODO (2016-10-07) Wrong/unused? How could it be "1"?
                                  return indent(info.plnum) - 1
                                  " If previous line is a continuation return its indent.
                                  " TODO: the || s:IsInString() thing worries me a bit.
                                elseif s:Match(info.plnum, s:non_bracket_continuation_regex) || s:IsInString(info.plnum, strlen(line))
                                  return indent(info.plnum)
                                endif
    2              0.000001   endif
                            
    2              0.000001   return -1

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/coc.vim line 18
Called 432 times
Total time:   0.010527
 Self time:   0.010527

count  total (s)   self (s)
  432              0.001731   if !exists(":CocCommand")
                                return ''
  432              0.000154   endif
  432              0.001208   let _backup = get(g:, 'coc_stl_format', '')
  432              0.000856   let is_err = (a:type  is# 'error')
  432              0.000329   if is_err
  216              0.000939     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
  216              0.000097   else
  216              0.001070     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
  432              0.000188   endif
  432              0.001024   let info = get(b:, 'coc_diagnostic_info', {})
  432              0.000870   if empty(info) | return '' | endif
                            
                            
                              let cnt = get(info, a:type, 0)
                              if !empty(_backup)
                                let g:coc_stl_format = _backup
                              endif
                            
                              if empty(cnt)
                                return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/tabline/buflist.vim line 35
Called 147 times
Total time:   0.000687
 Self time:   0.000687

count  total (s)   self (s)
  147              0.000419   if exists('s:current_buffer_list')
  147              0.000162     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  18()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/autoload/provider/clipboard.vim line 142
Called 1 time
Total time:   0.023642
 Self time:   0.000063

count  total (s)   self (s)
    1              0.000002   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
    1              0.000000   end
                            
    1              0.000006   if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
    1              0.000000   end
                            
    1              0.000001   if s:cache_enabled == 0
    1   0.023612   0.000032     call s:try_cmd(s:copy[a:reg], a:lines)
    1              0.000002     return 0
                              end
                            
                              if s:selections[a:reg].owner > 0
                                let prev_job = s:selections[a:reg].owner
                              end
                              let s:selections[a:reg] = copy(s:selection)
                              let selection = s:selections[a:reg]
                              let selection.data = [a:lines, a:regtype]
                              let argv = split(s:copy[a:reg], " ")
                              let selection.argv = argv
                              let selection.detach = s:cache_enabled
                              let selection.cwd = "/"
                              let jobid = jobstart(argv, selection)
                              if jobid > 0
                                call jobsend(jobid, a:lines)
                                call jobclose(jobid, 'stdin')
                                let selection.owner = jobid
                                let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
                              endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
                              if exists('prev_job')
                                call timer_start(1000, {... -> jobwait([prev_job], 0)[0] == -1 && jobstop(prev_job)})
                              endif
                            
                              return ret

FUNCTION  <SNR>43_abs_path()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 189
Called 100 times
Total time:   0.021239
 Self time:   0.021239

count  total (s)   self (s)
  100              0.020403   let p = resolve(expand('#'.a:bufnr.':p'))
  100              0.000711   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>86_CheckDefined()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 132
Called 1056 times
Total time:   0.021226
 Self time:   0.021226

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 1056              0.003015   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
 1056              0.000433   endif
 1056              0.002939   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
 1056              0.000381   endif
                            
 1056              0.001919   for val in a:colors
 1056              0.002379     if !empty(val) && val !=# 'NONE'
 1056              0.000972       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  coc#util#get_complete_option()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc/util.vim line 384
Called 8 times
Total time:   0.007624
 Self time:   0.007624

count  total (s)   self (s)
    8              0.000046   let disabled = get(b:, 'coc_suggest_disable', 0)
    8              0.000016   if disabled | return | endif
    8              0.000020   let blacklist = get(b:, 'coc_suggest_blacklist', [])
    8              0.000018   let pos = getcurpos()
    8              0.000014   let l:start = pos[2] - 1
    8              0.000017   let line = getline(pos[1])
   38              0.000238   for char in reverse(split(line[0: l:start - 1], '\zs'))
   38              0.000200     if l:start > 0 && char =~# '\k'
   30              0.000071       let l:start = l:start - strlen(char)
    8              0.000004     else
    8              0.000004       break
   30              0.000010     endif
   38              0.000047   endfor
    8              0.000027   let input = pos[2] == 1 ? '' : line[l:start : pos[2] - 2]
    8              0.000022   if !empty(blacklist) && index(blacklist, input) >= 0
                                return
    8              0.000003   endif
    8              0.005926   let synname = synIDattr(synID(pos[1], l:start, 1),"name")
    8              0.000018   if !synname
    8              0.000014     let synname = ''
    8              0.000005   endif
    8              0.000806   return { 'word': matchstr(line[l:start : ], '^\k\+'), 'input': input, 'line': line, 'filetype': &filetype, 'filepath': expand('%:p'), 'bufnr': bufnr('%'), 'linenr': pos[1], 'colnr' : pos[2], 'col': l:start, 'synname': synname, 'blacklist': blacklist,}

FUNCTION  <SNR>126_build_command()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/async.vim line 40
Called 14 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
   14              0.000042   if has('unix')
   14              0.000044     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  <SNR>122_AfterUnbalancedBracket()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 525
Called 2 times
Total time:   0.001501
 Self time:   0.000162

count  total (s)   self (s)
    2              0.000004   let info = a:pline_info
                            
                              " If the previous line contained unclosed opening brackets and we are still
                              " in them, find the rightmost one and add indent depending on the bracket
                              " type.
                              "
                              " If it contained hanging closing brackets, find the rightmost one, find its
                              " match and indent according to that.
    2              0.000022   if info.pline =~ '[[({]' || info.pline =~ '[])}]\s*\%(#.*\)\=$'
    2   0.001378   0.000040     let [opening, closing] = s:ExtraBrackets(info.plnum)
                            
    2              0.000003     if opening.pos != -1
                                  if opening.type == '(' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                    if col('.') + 1 == col('$')
                                      return indent(info.plnum) + info.sw
                                    else
                                      return virtcol('.')
                                    endif
                                  else
                                    let nonspace = matchend(info.pline, '\S', opening.pos + 1) - 1
                                    return nonspace > 0 ? nonspace : indent(info.plnum) + info.sw
                                  endif
    2              0.000003     elseif closing.pos != -1
                                  call cursor(info.plnum, closing.pos + 1)
                                  normal! %
                            
                                  if s:Match(line('.'), s:ruby_indent_keywords)
                                    return indent('.') + info.sw
                                  else
                                    return indent(s:GetMSL(line('.')))
                                  endif
    2              0.000001     else
    2              0.000008       call cursor(info.clnum, info.col)
    2              0.000001     end
    2              0.000001   endif
                            
    2              0.000002   return -1

FUNCTION  <SNR>122_MultilineStringOrLineComment()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 376
Called 2 times
Total time:   0.000700
 Self time:   0.000190

count  total (s)   self (s)
    2              0.000020   let info = a:cline_info
                            
                              " If we are in a multi-line string or line-comment, don't do anything to it.
    2   0.000655   0.000146   if s:IsInStringOrDocumentation(info.clnum, matchend(info.cline, '^\s*') + 1)
                                return indent(info.clnum)
    2              0.000002   endif
    2              0.000002   return -1

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 215
Called 14 times
Total time:   0.000651
 Self time:   0.000651

count  total (s)   self (s)
   14              0.000307   let matches = matchlist(a:line, s:hunk_re)
   14              0.000040   if len(matches) > 0
   14              0.000045     let from_line  = str2nr(matches[1])
   14              0.000065     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   14              0.000039     let to_line    = str2nr(matches[3])
   14              0.000043     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   14              0.000071     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>126_on_stdout_nvim()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/async.vim line 53
Called 28 times
Total time:   0.000592
 Self time:   0.000592

count  total (s)   self (s)
   28              0.000199   if empty(self.stdoutbuffer)
   14              0.000075     let self.stdoutbuffer = a:data
   14              0.000009   else
   14              0.000117     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
   28              0.000016   endif

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 230
Called 14 times
Total time:   0.007403
 Self time:   0.000580

count  total (s)   self (s)
   14              0.000032   let modified_lines = []
   28              0.000034   for hunk in a:hunks
   14   0.007219   0.000396     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   28              0.000023   endfor
   14              0.000014   return modified_lines

FUNCTION  <SNR>122_AfterAccessModifier()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 432
Called 2 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000005   let info = a:pline_info
                            
    2              0.000006   if g:ruby_indent_access_modifier_style == 'indent'
                                " If the previous line was a private/protected keyword, add a
                                " level of indent.
                                if s:Match(info.plnum, s:indent_access_modifier_regex)
                                  return indent(info.plnum) + info.sw
                                endif
    2              0.000005   elseif g:ruby_indent_access_modifier_style == 'outdent'
                                " If the previous line was a private/protected/public keyword, add
                                " a level of indent, since the keyword has been out-dented.
                                if s:Match(info.plnum, s:access_modifier_regex)
                                  return indent(info.plnum) + info.sw
                                endif
    2              0.000001   endif
    2              0.000002   return -1

FUNCTION  <SNR>43_not_git_dir()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 65
Called 29 times
Total time:   0.008033
 Self time:   0.000968

count  total (s)   self (s)
   29   0.008005   0.000939   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>50_get_channel()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc/client.vim line 94
Called 158 times
Total time:   0.001119
 Self time:   0.001119

count  total (s)   self (s)
  158              0.000230   if s:is_vim
                                return a:client['channel']
  158              0.000114   endif
  158              0.000268   return a:client['chan_id']

FUNCTION  <SNR>43_unc_path()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 171
Called 14 times
Total time:   0.002707
 Self time:   0.000245

count  total (s)   self (s)
   14   0.002657   0.000195   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/util.vim line 41
Called 1986 times
Total time:   0.016554
 Self time:   0.013084

count  total (s)   self (s)
 1986   0.011222   0.007752   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1986              0.000812   endif
 1986              0.001754   return a:text

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/debug.vim line 80
Called 28 times
Total time:   0.001187
 Self time:   0.001187

count  total (s)   self (s)
   28              0.000066   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   28              0.000018   endif

FUNCTION  <SNR>126_on_stderr_nvim()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/async.vim line 63
Called 14 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
   14              0.000066   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
   14              0.000006   endif

FUNCTION  <SNR>122_AfterLeadingOperator()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 506
Called 2 times
Total time:   0.000088
 Self time:   0.000032

count  total (s)   self (s)
                              " If the previous line started with a leading operator, use its MSL's level
                              " of indent
    2   0.000076   0.000019   if s:Match(a:pline_info.plnum, s:leading_operator_regex)
                                return indent(s:GetMSL(a:pline_info.plnum))
    2              0.000001   endif
    2              0.000001   return -1

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/tabline.vim line 194
Called 147 times
Total time:   0.025026
 Self time:   0.004430

count  total (s)   self (s)
  147   0.002378   0.001691   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
  147              0.000471   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
  147   0.022050   0.002141   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>122_ClosingHeredocDelimiter()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 386
Called 2 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000005   let info = a:cline_info
                            
                              " If we are at the closing delimiter of a "<<" heredoc-style string, set the
                              " indent to 0.
    2              0.000025   if info.cline =~ '^\k\+\s*$' && s:IsInStringDelimiter(info.clnum, 1) && search('\V<<'.info.cline, 'nbW') > 0
                                return 0
    2              0.000001   endif
                            
    2              0.000002   return -1

FUNCTION  <SNR>122_IsInStringOrComment()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 682
Called 16 times
Total time:   0.013790
 Self time:   0.000286

count  total (s)   self (s)
   16   0.013782   0.000278   return s:IsInRubyGroup(s:syng_strcom, a:lnum, a:col)

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 229
Called 8 times
Total time:   0.003836
 Self time:   0.000408

count  total (s)   self (s)
    8              0.000037   if getbufvar(a:bufnr, '&modified')
    8              0.000123     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    8              0.000005   endif
                            
    8              0.000016   if !empty(colors)
    8   0.003587   0.000159     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    8              0.000004   endif

FUNCTION  <SNR>90_update_branch()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/branch.vim line 158
Called 216 times
Total time:   0.150421
 Self time:   0.013073

count  total (s)   self (s)
  648              0.001720   for vcs in keys(s:vcs_config)
  432   0.143040   0.005692     call {s:vcs_config[vcs].update_branch}()
  432              0.001718     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
  432              0.000226     endif
  648              0.000565   endfor

FUNCTION  FugitiveHead()
    Defined: ~/.vim/z_plugins/vim-fugitive/plugin/fugitive.vim line 110
Called 216 times
Total time:   0.114200
 Self time:   0.005229

count  total (s)   self (s)
  216   0.006791   0.001971   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
  216              0.000355   if empty(dir)
                                return ''
  216              0.000092   endif
  216   0.106543   0.002393   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 243
Called 8 times
Total time:   0.508851
 Self time:   0.053669

count  total (s)   self (s)
    8              0.000026   let bufnr = a:0 ? a:1 : ''
    8              0.000045   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    8              0.000141   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    8              0.000035   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    8              0.000023   let airline_grouplist = []
    8              0.000134   let buffers_in_tabpage = sort(tabpagebuflist())
    8              0.000027   if exists("*uniq")
    8              0.000070     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    8              0.000011   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   24              0.000055   for mode in reverse(mapped)
   16              0.000098     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   16              0.000049       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  810              0.001818       for kvp in items(dict)
  794              0.001039         let mode_colors = kvp[1]
  794              0.000994         let name = kvp[0]
  794              0.001742         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
  794              0.000321         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  794              0.004136         if name =~# 'airline_c\d\+'
  315              0.002184           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
  315              0.000744           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
  255              0.000165             continue
   60              0.000024           endif
  479              0.001975         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  375              0.000260           continue
  164              0.000069         endif
  164   0.002725   0.001446         if s:group_not_done(airline_grouplist, name.suffix)
  104   0.030571   0.001406           call airline#highlighter#exec(name.suffix, mode_colors)
  164              0.000077         endif
                            
  492              0.000869         for accent in keys(s:accents)
  328              0.000716           if !has_key(p.accents, accent)
                                        continue
  328              0.000140           endif
  328              0.001270           let colors = copy(mode_colors)
  328              0.000681           if p.accents[accent][0] != ''
  164              0.000326             let colors[0] = p.accents[accent][0]
  328              0.000133           endif
  328              0.000532           if p.accents[accent][2] != ''
                                        let colors[2] = p.accents[accent][2]
  328              0.000126           endif
  328              0.000451           if len(colors) >= 5
  328              0.000934             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
  328              0.000138           endif
  328   0.005653   0.003237           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  208   0.057494   0.002634             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  328              0.000154           endif
  492              0.000282         endfor
  180              0.000119       endfor
                            
   16              0.000030       if empty(s:separators)
                                    " nothing to be done
                                    continue
   16              0.000007       endif
                                  " TODO: optimize this
  752              0.001678       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  736   0.375596   0.008133         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  752              0.000556       endfor
   16              0.000007     endif
   24              0.000055   endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/z_plugins/coc.nvim/autoload/coc/rpc.vim line 30
Called 158 times
Total time:   0.001458
 Self time:   0.001458

count  total (s)   self (s)
  158              0.001043   if empty(s:client) || s:client['running'] == 0 | return 0 | endif
  158              0.000170   return 1

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/parts.vim line 108
Called 222 times
Total time:   0.005315
 Self time:   0.005315

count  total (s)   self (s)
  222              0.000798   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  222              0.000448   let bomb     = &l:bomb ? '[BOM]' : ''
  222              0.001786   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  222              0.000987   if expected is# &fenc.bomb.ff
                                return ''
  222              0.000110   else
  222              0.000704     return &fenc.bomb.ff
                              endif

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 79
Called 71 times
Total time:   0.002870
 Self time:   0.002667

count  total (s)   self (s)
   71              0.002081   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   57              0.000150     return a:arg
   14   0.000395   0.000191   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
   14              0.000013   else
   14              0.000051     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/util.vim line 124
Called 234 times
Total time:   0.012295
 Self time:   0.012295

count  total (s)   self (s)
  234              0.001818   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  234              0.010202   return match(a:name, pat) > -1

FUNCTION  <SNR>106_try_cmd()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/autoload/provider/clipboard.vim line 37
Called 1 time
Total time:   0.023580
 Self time:   0.000276

count  total (s)   self (s)
    1              0.000008   let argv = split(a:cmd, " ")
    1   0.023539   0.000235   let out = systemlist(argv, (a:0 ? a:1 : ['']), 1)
    1              0.000008   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
    1              0.000000   endif
    1              0.000001   return out

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/util.vim line 18
Called 2361 times
Total time:   0.020952
 Self time:   0.020952

count  total (s)   self (s)
 2361              0.006561   let nr = get(a:000, 0, 0)
 2361              0.004898   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
 2361              0.001569   else
 2361              0.003822     return winwidth(nr)
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim/z_plugins/vim-fugitive/autoload/fugitive.vim line 494
Called 216 times
Total time:   0.104150
 Self time:   0.017975

count  total (s)   self (s)
  216              0.000731   let dir = a:0 > 1 ? a:2 : s:Dir()
  216              0.000375   if empty(dir)
                                return ''
  216              0.000094   endif
  216   0.088268   0.002093   let file = fugitive#Find('.git/HEAD', dir)
  216              0.005929   let ftime = getftime(file)
  216              0.000359   if ftime == -1
                                return ''
  216              0.001389   elseif ftime != get(s:head_cache, dir, [-1])[0]
                                let s:head_cache[dir] = [ftime, readfile(file)[0]]
  216              0.000107   endif
  216              0.000565   let head = s:head_cache[dir][1]
  216              0.001213   if head =~# '^ref: '
  216              0.003739     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline.vim line 273
Called 33 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
   33              0.000136   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   33              0.000043   endif

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/sign.vim line 57
Called 14 times
Total time:   0.013265
 Self time:   0.011602

count  total (s)   self (s)
   14              0.000035   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
   14              0.000369     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
   14   0.000275   0.000144     let modified_lines = s:handle_double_hunk(a:modified_lines)
   14   0.009244   0.007712     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
   14              0.000031     if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
   14              0.000007     endif
                            
  671              0.000379     for sign in signs
  657              0.002426       call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
  671              0.000270     endfor
   14              0.000009     return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/hunks.vim line 63
Called 216 times
Total time:   0.063001
 Self time:   0.029226

count  total (s)   self (s)
  216              0.000651   if !get(w:, 'airline_active', 0)
                                return ''
  216              0.000103   endif
                              " Cache values, so that it isn't called too often
  216   0.006593   0.004940   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
  216              0.000102   endif
  216   0.026144   0.002312   let hunks = airline#extensions#hunks#get_raw_hunks()
  216              0.000272   let string = ''
  216   0.003087   0.002103   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  216              0.000492   if !empty(hunks)
  864              0.001360     for i in [0, 1, 2]
  648   0.011659   0.006029       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  648              0.003913         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  648              0.000440       endif
  864              0.000754     endfor
  216              0.000110   endif
  216              0.000474   let b:airline_hunks = string
  216              0.000436   let b:airline_changenr = b:changedtick
  216   0.003352   0.001676   let s:airline_winwidth = airline#util#winwidth()
  216              0.000212   return string

FUNCTION  fugitive#CommonDir()
    Defined: ~/.vim/z_plugins/vim-fugitive/autoload/fugitive.vim line 283
Called 216 times
Total time:   0.005501
 Self time:   0.005501

count  total (s)   self (s)
  216              0.000475   if empty(a:dir)
                                return ''
  216              0.000112   endif
  216              0.000585   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
  216              0.000080   endif
  216              0.000446   return s:commondirs[a:dir]

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/parts.vim line 89
Called 234 times
Total time:   0.017694
 Self time:   0.005399

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  234   0.015328   0.003033   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
  234              0.000179   endif
  234              0.000641   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
  234              0.000119   else
  234              0.000367     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>86_group_not_done()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 25
Called 492 times
Total time:   0.003694
 Self time:   0.003694

count  total (s)   self (s)
  492              0.001341   if index(a:list, a:name) == -1
  312              0.000813     call add(a:list, a:name)
  312              0.000246     return 1
  180              0.000065   else
  180              0.000161     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
  180              0.000067     endif
  180              0.000085     return 0
                              endif

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 9
Called 56 times
Total time:   0.001100
 Self time:   0.001100

count  total (s)   self (s)
   56              0.000097   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   56              0.000112   let bvars = getbufvar(buffer, '')
   56              0.000070   if empty(bvars)
                                let bvars = {}
   56              0.000023   endif
   56              0.000121   let dict = get(bvars, 'gitgutter', {})
   56              0.000087   let needs_setting = empty(dict)
   56              0.000267   let dict[a:varname] = a:val
   56              0.000039   if needs_setting
                                call setbufvar(buffer, 'gitgutter', dict)
   56              0.000019   endif

FUNCTION  <SNR>86_get_array()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/highlighter.vim line 56
Called 2528 times
Total time:   0.017686
 Self time:   0.017686

count  total (s)   self (s)
 2528              0.007050   let opts=empty(a:opts) ? '' : join(a:opts, ',')
 2528              0.009347   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  <SNR>122_AfterHangingSplat()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 515
Called 2 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    2              0.000005   let info = a:pline_info
                            
                              " If the previous line ended with the "*" of a splat, add a level of indent
    2              0.000055   if info.pline =~ s:splat_regex
                                return indent(info.plnum) + info.sw
    2              0.000001   endif
    2              0.000002   return -1

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 114
Called 71 times
Total time:   0.003201
 Self time:   0.001499

count  total (s)   self (s)
   71   0.002341   0.001027   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
   71   0.000763   0.000376   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>47_Autocmd()
    Defined: ~/.vim/z_plugins/coc.nvim/plugin/coc.vim line 140
Called 158 times
Total time:   0.023783
 Self time:   0.003879

count  total (s)   self (s)
  158              0.001194   if !get(g:,'coc_workspace_initialized', 0) | return | endif
  158   0.022320   0.002416   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>122_IndentingKeywordInMSL()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 632
Called 2 times
Total time:   0.000205
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000003   let info = a:msl_info
                              " If the MSL line had an indenting keyword in it, add a level of indent.
                              " TODO: this does not take into account contrived things such as
                              " module Foo; class Bar; end
    2   0.000162   0.000016   let col = s:Match(info.plnum_msl, s:ruby_indent_keywords)
    2              0.000002   if col > 0
                                let ind = indent(info.plnum_msl) + info.sw
                                if s:Match(info.plnum_msl, s:end_end_regex)
                                  let ind = ind - info.sw
                                elseif s:IsAssignment(getline(info.plnum_msl), col)
                                  if g:ruby_indent_assignment_style == 'hanging'
                                    " hanging indent
                                    let ind = col + info.sw - 1
                                  else
                                    " align with variable
                                    let ind = indent(info.plnum_msl) + info.sw
                                  endif
                                endif
                                return ind
    2              0.000001   endif
    2              0.000001   return -1

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 216
Called 14 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
   14              0.000144   return has('win64') || has('win32') || has('win16')

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/hunk.vim line 18
Called 230 times
Total time:   0.007513
 Self time:   0.003822

count  total (s)   self (s)
  230   0.007317   0.003626   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>122_AccessModifier()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 274
Called 2 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000005   let info = a:cline_info
                            
                              " If this line is an access modifier keyword, align according to the closest
                              " class declaration.
    2              0.000007   if g:ruby_indent_access_modifier_style == 'indent'
                                if s:Match(info.clnum, s:access_modifier_regex)
                                  let class_lnum = s:FindContainingClass()
                                  if class_lnum > 0
                                    return indent(class_lnum) + info.sw
                                  endif
                                endif
    2              0.000005   elseif g:ruby_indent_access_modifier_style == 'outdent'
                                if s:Match(info.clnum, s:access_modifier_regex)
                                  let class_lnum = s:FindContainingClass()
                                  if class_lnum > 0
                                    return indent(class_lnum)
                                  endif
                                endif
    2              0.000001   endif
                            
    2              0.000002   return -1

FUNCTION  <SNR>122_LeadingOperator()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 400
Called 2 times
Total time:   0.000310
 Self time:   0.000105

count  total (s)   self (s)
                              " If the current line starts with a leading operator, add a level of indent.
    2   0.000266   0.000060   if s:Match(a:cline_info.clnum, s:leading_operator_regex)
                                return indent(s:GetMSL(a:cline_info.clnum)) + a:cline_info.sw
    2              0.000002   endif
    2              0.000009   return -1

FUNCTION  <SNR>122_AfterBlockOpening()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 480
Called 2 times
Total time:   0.000222
 Self time:   0.000081

count  total (s)   self (s)
    2              0.000005   let info = a:pline_info
                            
                              " If the previous line ended with a block opening, add a level of indent.
    2   0.000164   0.000023   if s:Match(info.plnum, s:block_regex)
                                if g:ruby_indent_block_style == 'do'
                                  " don't align to the msl, align to the "do"
                                  let ind = indent(info.plnum) + info.sw
                                else
                                  let plnum_msl = s:GetMSL(info.plnum)
                            
                                  if getline(plnum_msl) =~ '=\s*\(#.*\)\=$'
                                    " in the case of assignment to the msl, align to the starting line,
                                    " not to the msl
                                    let ind = indent(info.plnum) + info.sw
                                  else
                                    let ind = indent(plnum_msl) + info.sw
                                  endif
                                endif
                            
                                return ind
    2              0.000001   endif
                            
    2              0.000002   return -1

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim line 35
Called 147 times
Total time:   0.002381
 Self time:   0.002381

count  total (s)   self (s)
  147              0.000439   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
  147              0.000905   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
  147              0.000441   if getbufvar(a:bufnr, '&modified') == 1
   21              0.000043     let _ .= s:buf_modified_symbol
  147              0.000066   endif
  147              0.000126   return _

FUNCTION  <SNR>105_setup_path()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter.vim line 158
Called 29 times
Total time:   0.002017
 Self time:   0.000807

count  total (s)   self (s)
   29   0.001795   0.000585   let p = gitgutter#utility#repo_path(a:bufnr, 0)
                            
   29              0.000138   if type(p) == s:t_string && !empty(p)  " if path is known
   29              0.000025     return
                              endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>126_on_exit_nvim()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/async.vim line 69
Called 14 times
Total time:   0.026414
 Self time:   0.000582

count  total (s)   self (s)
   14              0.000054   if !a:exit_code
   14   0.026333   0.000501     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
   14              0.000006   endif

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/z_plugins/vim-gitgutter/plugin/gitgutter.vim line 179
Called 216 times
Total time:   0.010172
 Self time:   0.002989

count  total (s)   self (s)
  216   0.010018   0.002834   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  <SNR>43_is_file_buffer()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/utility.vim line 69
Called 29 times
Total time:   0.000425
 Self time:   0.000425

count  total (s)   self (s)
   29              0.000375   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>122_DeindentingKeyword()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 335
Called 2 times
Total time:   0.000537
 Self time:   0.000346

count  total (s)   self (s)
    2              0.000005   let info = a:cline_info
                            
                              " If we have a deindenting keyword, find its match and indent to its level.
                              " TODO: this is messy
    2   0.000279   0.000087   if s:Match(info.clnum, s:ruby_deindent_keywords)
                                call cursor(info.clnum, 1)
                            
                                if searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW', s:end_skip_expr) > 0
                                  let msl  = s:GetMSL(line('.'))
                                  let line = getline(line('.'))
                            
                                  if s:IsAssignment(line, col('.')) && strpart(line, col('.') - 1, 2) !~ 'do'
                                    " assignment to case/begin/etc, on the same line
                                    if g:ruby_indent_assignment_style == 'hanging'
                                      " hanging indent
                                      let ind = virtcol('.') - 1
                                    else
                                      " align with variable
                                      let ind = indent(line('.'))
                                    endif
                                  elseif g:ruby_indent_block_style == 'do'
                                    " align to line of the "do", not to the MSL
                                    let ind = indent(line('.'))
                                  elseif getline(msl) =~ '=\s*\(#.*\)\=$'
                                    " in the case of assignment to the MSL, align to the starting line,
                                    " not to the MSL
                                    let ind = indent(line('.'))
                                  else
                                    " align to the MSL
                                    let ind = indent(msl)
                                  endif
                                endif
                                return ind
    2              0.000001   endif
                            
    2              0.000005   return -1

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/diff.vim line 172
Called 14 times
Total time:   0.025832
 Self time:   0.001780

count  total (s)   self (s)
   14   0.000604   0.000094   call gitgutter#debug#log(a:diff)
                            
   14              0.000029   if !bufexists(a:bufnr)
                                return
   14              0.000005   endif
                            
   14   0.002418   0.000205   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
   14   0.007821   0.000158   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
   14              0.000027   let signs_count = len(modified_lines)
   14              0.000021   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
   14              0.000007   else
   14              0.000041     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
   14   0.014025   0.000760       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
   14              0.000008     endif
   14              0.000005   endif
                            
   14   0.000529   0.000128   call s:save_last_seen_change(a:bufnr)
   14              0.000077   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
   14              0.000005   endif

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/hunk.vim line 26
Called 14 times
Total time:   0.000921
 Self time:   0.000363

count  total (s)   self (s)
   14   0.000441   0.000112   let summary = gitgutter#hunk#summary(a:bufnr)
   14              0.000024   let summary[0] += a:count
   14   0.000432   0.000203   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>130_reset_summary()
    Defined: ~/.vim/z_plugins/vim-gitgutter/autoload/gitgutter/hunk.vim line 22
Called 14 times
Total time:   0.000381
 Self time:   0.000129

count  total (s)   self (s)
   14   0.000351   0.000100   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/util.vim line 138
Called 216 times
Total time:   0.001593
 Self time:   0.001593

count  total (s)   self (s)
  216              0.000620   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
  216              0.000110   endif
  216              0.000253   return s:has_lawrencium

FUNCTION  provider#clipboard#Call()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/autoload/provider/clipboard.vim line 195
Called 1 time
Total time:   0.023696
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000008   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
    1              0.000001   endif
    1              0.000002   let s:here = v:true
    1              0.000001   try
    1   0.023671   0.000029     return call(s:clipboard[a:method],a:args,s:clipboard)
    1              0.000003   finally
    1              0.000003     let s:here = v:false
    1              0.000001   endtry

FUNCTION  <SNR>51_on_window_changed()
    Defined: ~/.vim/z_plugins/vim-airline/plugin/airline.vim line 48
Called 6 times
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
    6              0.000021   let s:active_winnr = winnr()
                            
    6              0.000012   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
    6              0.000002   endif
                              " work around a neovim bug: do not trigger on floating windows
                              " Disabled, Bug is fixed in Neovim, TODO: should be removed soon
                              " if exists("*nvim_win_get_config") && !empty(nvim_win_get_config(0).relative)
                              "  return
                              " endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    6              0.000039   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    6              0.000080   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    6              0.000004     return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()

FUNCTION  <SNR>22_is_space_expansion()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 141
Called 7 times
Total time:   0.001361
 Self time:   0.000483

count  total (s)   self (s)
    7              0.000021   if col('.') > 2
    7   0.000260   0.000055     let pchar = s:get_char(-2)
    7   0.000159   0.000050     let nchar = s:get_char(1)
    7   0.000392   0.000128     let isSpaces = (s:get_char(-1)   == s:get_char(0) && s:get_char(-1) == " ")
                            
    7   0.000256   0.000088     if index(s:get('left_delims'), pchar) > -1 && index(s:get('left_delims'), pchar)   == index(s:get('right_delims'), nchar) && isSpaces
                                  return 1
    7   0.000226   0.000094     elseif index(s:get('quotes_list'), pchar) > -1 && index(s:get('quotes_list'), pchar)   == index(s:get('quotes_list'), nchar) && isSpaces
                                  return 1
    7              0.000004     endif
    7              0.000003   endif
    7              0.000005   return 0

FUNCTION  <SNR>22_get()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 32
Called 56 times
Total time:   0.001070
 Self time:   0.001070

count  total (s)   self (s)
   56              0.000071   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
   56              0.000049   elseif a:0 == 1
                                let bufoptions = get(s:options, bufnr('%'), {})
                                return deepcopy(get(bufoptions, a:name, a:1))
   56              0.000028   else
   56              0.000452     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  <SNR>122_ClosingBracketOnEmptyLine()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/ruby.vim line 298
Called 2 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    2              0.000004   let info = a:cline_info
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
    2              0.000033   let col = matchend(info.cline, '^\s*[]})]')
                            
    2              0.000008   if col > 0 && !s:IsInStringOrComment(info.clnum, col)
                                call cursor(info.clnum, col)
                                let closing_bracket = info.cline[col - 1]
                                let bracket_pair = strpart('(){}[]', stridx(')}]', closing_bracket) * 2, 2)
                            
                                if searchpair(escape(bracket_pair[0], '\['), '', bracket_pair[1], 'bW', s:skip_expr) > 0
                                  if closing_bracket == ')' && col('.') != col('$') - 1
                                    let ind = virtcol('.') - 1
                                  elseif g:ruby_indent_block_style == 'do'
                                    let ind = indent(line('.'))
                                  else " g:ruby_indent_block_style == 'expression'
                                    let ind = indent(s:GetMSL(line('.')))
                                  endif
                                endif
                            
                                return ind
    2              0.000001   endif
                            
    2              0.000002   return -1

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/z_plugins/vim-airline/autoload/airline/extensions/keymap.vim line 10
Called 216 times
Total time:   0.002476
 Self time:   0.002476

count  total (s)   self (s)
  216              0.001111   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  216              0.001127     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  delimitMate#BS()
    Defined: ~/.vim/z_plugins/delimitMate/autoload/delimitMate.vim line 529
Called 7 times
Total time:   0.006827
 Self time:   0.000704

count  total (s)   self (s)
    7   0.003415   0.000224   if s:is_forbidden("")
                                let extra = ''
    7              0.000125   elseif &bs !~ 'start\|2'
                                let extra = ''
    7   0.000836   0.000081   elseif delimitMate#WithinEmptyPair()
                                let extra = "\<Del>"
    7   0.001445   0.000083   elseif s:is_space_expansion()
                                let extra = "\<Del>"
    7   0.000890   0.000074   elseif s:is_cr_expansion()
                                let extra = repeat("\<Del>", len(matchstr(getline(line('.') + 1), '^\s*\S')))
    7              0.000003   else
    7              0.000008     let extra = ''
    7              0.000003   endif
    7              0.000016   return "\<BS>" . extra

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  234   0.542910   0.029207  airline#check_mode()
    8   0.508851   0.053669  airline#highlighter#highlight()
  736   0.367463   0.032350  <SNR>86_exec_separator()
 2528   0.284968   0.140755  airline#highlighter#get_highlight()
 1056   0.236994   0.064820  airline#highlighter#exec()
  216   0.219078   0.010843  airline#extensions#branch#get_head()
  216   0.199305   0.008434  airline#extensions#branch#head()
 1472   0.185571   0.016750  airline#themes#get_highlight()
  216   0.150421   0.013073  <SNR>90_update_branch()
 5056   0.126528             <SNR>86_get_syn()
  216   0.124157   0.008045  <SNR>90_update_git_branch()
  216   0.114200   0.005229  FugitiveHead()
  216   0.104150   0.017975  fugitive#Head()
   29   0.098596   0.004599  gitgutter#process_buffer()
  216   0.086176   0.056655  fugitive#Find()
   14   0.065964   0.005383  gitgutter#diff#run_diff()
  216   0.063001   0.029226  airline#extensions#hunks#get_hunks()
  216   0.040449   0.037453  <SNR>90_update_untracked()
   14   0.039960   0.039175  gitgutter#async#execute()
  216   0.034152   0.023724  airline#extensions#whitespace#check()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 2528   0.284968   0.140755  airline#highlighter#get_highlight()
 5056              0.126528  <SNR>86_get_syn()
 1056   0.236994   0.064820  airline#highlighter#exec()
  216   0.086176   0.056655  fugitive#Find()
    8   0.508851   0.053669  airline#highlighter#highlight()
   14   0.039960   0.039175  gitgutter#async#execute()
  216   0.040449   0.037453  <SNR>90_update_untracked()
  736   0.367463   0.032350  <SNR>86_exec_separator()
  234   0.031049   0.030020  airline#extensions#fugitiveline#bufname()
  216   0.063001   0.029226  airline#extensions#hunks#get_hunks()
  234   0.542910   0.029207  airline#check_mode()
  408              0.027347  <SNR>86_GetHiCmd()
  216   0.034152   0.023724  airline#extensions#whitespace#check()
  100              0.021239  <SNR>43_abs_path()
 1056              0.021226  <SNR>86_CheckDefined()
 2361              0.020952  airline#util#winwidth()
  216   0.104150   0.017975  fugitive#Head()
 2528              0.017686  <SNR>86_get_array()
  147   0.019909   0.017528  airline#extensions#tabline#formatters#default#format()
 1472   0.185571   0.016750  airline#themes#get_highlight()

